{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>A Python library of interactive CLI elements you have been looking for</p> <p> </p> <p></p> <p>For documentation but more and prettier see here</p>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>BeauPy stands on the shoulders of giants. It is based on another library with which it shares some of the source code, <code>cutie</code>, developed by Kamik423. It has begun as a fork but has since diverged into its own thing and as such, detached from the original repository.</p>"},{"location":"#overview","title":"Overview","text":"<p>BeauPy implements a number of common interactive elements:</p> Function Functionality <code>select</code> Prompt to pick a choice from a list <code>select_multiple</code> Prompt to select one or multiple choices from a list <code>confirm</code> Prompt with a question and yes/no options <code>prompt</code> Prompt that takes free input with optional validation, type conversion and input hiding <p>TUI elements shown in the above gif are the result of the following code:</p> <pre><code>import time\nfrom beaupy import confirm, prompt, select, select_multiple\nfrom beaupy.spinners import *\nfrom rich.console import Console\n\nconsole = Console()\n\n# Confirm a dialog\nif confirm(\"Will you take the ring to Mordor?\"):\n    names = [\n        \"Frodo Baggins\",\n        \"Samwise Gamgee\",\n        \"Legolas\",\n        \"Aragorn\",\n        \"[red]Sauron[/red]\",\n    ]\n    console.print(\"Who are you?\")\n    # Choose one item from a list\n    name = select(names, cursor=\"\ud83e\udca7\", cursor_style=\"cyan\")\n    console.print(f\"Al\u00e1men\u00eb, {name}\")\n\n\n    item_options = [\n        \"The One Ring\",\n        \"Dagger\",\n        \"Po-tae-toes\",\n        \"Lightsaber (Wrong franchise! Nevermind, roll with it!)\",\n    ]\n    console.print(\"What do you bring with you?\")\n    # Choose multiple options from a list\n    items = select_multiple(item_options, tick_character='\ud83c\udf92', ticked_indices=[0], maximal_count=3)\n\n    potato_count = 0\n    if \"Po-tae-toes\" in items:\n        # Prompt with type conversion and validation\n        potato_count = prompt('How many potatoes?', target_type=int, validator=lambda count: count &gt; 0)\n\n    # Spinner to show while doing some work\n    spinner = Spinner(DOTS, \"Packing things...\")\n    spinner.start()\n\n    time.sleep(2)\n\n    spinner.stop()\n    # Get input without showing it being typed\n    if \"friend\" == prompt(\"Speak, [blue bold underline]friend[/blue bold underline], and enter\", secure=True).lower():\n\n        # Custom spinner animation\n        spinner_animation = ['\u2589\u2589', '\u258c\u2590', '  ', '\u258c\u2590', '\u2589\u2589']\n        spinner = Spinner(spinner_animation, \"Opening the Door of Durin...\")\n        spinner.start()\n\n        time.sleep(2)\n\n        spinner.stop()\n    else:\n        spinner_animation = ['\ud83d\udc19\ud83c\udf0a    \u2694\ufe0f ', '\ud83d\udc19 \ud83c\udf0a   \u2694\ufe0f ', '\ud83d\udc19  \ud83c\udf0a  \u2694\ufe0f ', '\ud83d\udc19   \ud83c\udf0a \u2694\ufe0f ', '\ud83d\udc19    \ud83c\udf0a\u2694\ufe0f ']\n        spinner = Spinner(spinner_animation, \"Getting attacked by an octopus...\")\n        spinner.start()\n\n        time.sleep(2)\n\n        spinner.stop()\n\n    if 'The One Ring' in items:\n        console.print(\"[green]You throw The One Ring to a lava from an eagle![/green]\")\n    else:\n        console.print(\"[red]You forgot the ring and brought Middle-Earth to its knees![/red]\")\n    console.print(f\"And you brought {potato_count} taters!\")\n</code></pre> <p>For more information refer to more examples or definitive, but much less exciting API documentation</p>"},{"location":"#installation","title":"Installation","text":"<p>From PyPI:</p> <pre><code>pip install beaupy\n</code></pre> <p>From Conda (kindly set up and maintained by @thewchan):</p> <pre><code>conda config --add channels conda-forge\nconda config --set channel_priority strict\nconda install beaupy\n</code></pre> <p>From source:</p> <pre><code>git clone https://github.com/petereon/beaupy.git\npoetry build\npip install ./dist/beaupy-{{some-version}}-py3-none-any.whl\n</code></pre>"},{"location":"#roadmap","title":"Roadmap","text":"<p>This repository has a associated GitHub project where work that is currently done can be seen.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you would like to contribute, please feel free to suggest features or implement them yourself.</p> <p>Also please report any issues and bugs you might find!</p>"},{"location":"#development","title":"Development","text":"<p>To start development you can clone the repository:</p> <pre><code>git clone https://github.com/petereon/beaupy.git\n</code></pre> <p>Change the directory to the project directory:</p> <pre><code>cd ./beaupy/\n</code></pre> <p>This project uses <code>poetry</code> as a dependency manager. You can install the dependencies using:</p> <pre><code>poetry install\n</code></pre> <p>For testing, this project relies on pytest. It is included as a development dependency, so after installing the dependencies you can simply execute the following:</p> <pre><code>poetry run poe test\n</code></pre> <p>Making sure the code follows quality standards and formatting can be ensured by executing</p> <pre><code>poetry run poe lint\n</code></pre> <p>You can also have the tests and lints run after every saved change by executing a respective watch command</p> <pre><code>poetry run poe test:watch\n</code></pre> <p>or</p> <pre><code>poetry run poe lint:watch\n</code></pre> <p>After you have made your changes, create a pull request towards a master branch of this repository</p> <p>Looking forward to your pull requests!</p>"},{"location":"#compatibility","title":"Compatibility","text":"<p>Internal logic of <code>beaupy</code> is supported for all the major platforms (Windows, Linux, macOS).</p> <ul> <li>For user input from console, <code>beaupy</code> relies on petereon/yakh, which is tested against all the major platforms and Python versions.</li> <li>For printing to console <code>beaupy</code> relies on Textualize/rich, which supports all the major platforms.</li> </ul>"},{"location":"#known-issues","title":"Known Issues","text":"<ul> <li>From version <code>0.1.7</code> the CLI elements cause issue with displaying <code>pdb</code> prompt (#93).</li> <li>From version <code>2.0.0</code> arrow keys reportedly don't always work on Windows. Resolved in <code>3.0.0</code>.</li> <li>From version <code>3.5.0</code> there were various option display bugs in <code>select</code> and <code>select_multiple</code>. Resolved in <code>3.5.4</code>.</li> <li>From version <code>3.9.0</code>, the CLI elements default to persisting in the terminal after they finish executing. Resolved in <code>3.9.2</code>.</li> </ul>"},{"location":"#awesome-projects-using-beaupy","title":"Awesome projects using <code>beaupy</code>","text":"<ul> <li>therealOri/Genter: A strong password generator and built in password manager made with python3!</li> <li>therealOri/byte: Steganography Image/Data Injector. For artists or people to inject their own Datamark \"Watermark\" into their images/art or files!</li> <li>AnirudhG07/ntfyme: A notification tool to notify you about status of your long running processes on termination via local-notification, Gmail, Telergram, etc.</li> </ul>"},{"location":"#license","title":"License","text":"<p>The project is licensed under the MIT License.</p>"},{"location":"api/","title":"API Documentation","text":"<p>A Python library of interactive CLI elements you have been looking for</p> <p></p> <p></p>"},{"location":"api/#class-defaultkeys","title":"Class DefaultKeys","text":"<pre><code>class DefaultKeys()\n</code></pre> <p>[view_source]</p> <p>A map of default keybindings.</p> <p>Attributes:</p> <p>escape(List[Union[Tuple[int, ...], str]]): Keys that escape the current context.   select(List[Union[Tuple[int, ...], str]]): Keys that trigger list element selection.   confirm(List[Union[Tuple[int, ...], str]]): Keys that trigger list confirmation.   backspace(List[Union[Tuple[int, ...], str]]): Keys that trigger deletion of the previous character.   delete(List[Union[Tuple[int, ...], str]]): Keys that trigger deletion of the next character.   down(List[Union[Tuple[int, ...], str]]): Keys that select the element below.   up(List[Union[Tuple[int, ...], str]]): Keys that select the element above.   left(List[Union[Tuple[int, ...], str]]): Keys that select the element to the left.   right(List[Union[Tuple[int, ...], str]]): Keys that select the element to the right.   home(List[Union[Tuple[int, ...], str]]): Keys that move to the beginning of the context.   end(List[Union[Tuple[int, ...], str]]): Keys that move to the end of the context.</p> <p></p> <p></p>"},{"location":"api/#class-config","title":"Class Config","text":"<pre><code>class Config()\n</code></pre> <p>[view_source]</p> <p>A map of default configuration</p> <p>Attributes:</p> <ul> <li><code>raise_on_interrupt(bool)</code> - If True, functions will raise KeyboardInterrupt whenever one is encountered when waiting for input,   otherwise, they will return some sane alternative to their usual return. For <code>select</code>, <code>prompt</code> and <code>confirm</code> this means <code>None</code>,   while for <code>select_multiple</code> it means an empty list - <code>[]</code>. Defaults to False.</li> <li><code>raise_on_escape(bool)</code> - If True, functions will raise Abort whenever the escape key is encountered when waiting for input, otherwise,   they will return some sane alternative to their usual return. For <code>select</code>, <code>prompt</code> and <code>confirm</code> this means <code>None</code>, while for   <code>select_multiple</code> it means an empty list - <code>[]</code>.  Defaults to False.</li> <li><code>transient(bool)</code> - If False, elements will remain displayed after their context has ended. Defaults to True.</li> </ul> <p></p> <p></p>"},{"location":"api/#prompt","title":"prompt","text":"<pre><code>def prompt(\n        prompt: str,\n        target_type: Type[TargetType] = str,\n        validator: Callable[[TargetType], bool] = lambda input: True,\n        secure: bool = False,\n        raise_validation_fail: bool = True,\n        raise_type_conversion_fail: bool = True,\n        initial_value: Optional[str] = None,\n        completion: Optional[Callable[[str], List[str]]] = None) -&gt; TargetType\n</code></pre> <p>[view_source]</p> <p>Function that prompts the user for written input</p> <p>Arguments:</p> <ul> <li><code>prompt</code> str - The prompt that will be displayed</li> <li><code>target_type</code> Union[Type[T], Type[str]], optional - Type to convert the answer to. Defaults to str.</li> <li><code>validator</code> Callable[[Any], bool], optional - Optional function to validate the input. Defaults to lambda input: True.</li> <li><code>secure</code> bool, optional - If True, input will be hidden. Defaults to False.</li> <li><code>raise_validation_fail</code> bool, optional - If True, invalid inputs will raise <code>rich.internals.ValidationError</code>, else   the error will be reported onto the console. Defaults to True.</li> <li><code>raise_type_conversion_fail</code> bool, optional - If True, invalid inputs will raise <code>rich.internals.ConversionError</code>, else   the error will be reported onto the console. Defaults to True.</li> <li><code>initial_value</code> str, optional - If present, the value is placed in the prompt as the default value.</li> </ul> <p>Raises:</p> <ul> <li><code>ValidationError</code> - Raised if validation with provided validator fails</li> <li><code>ConversionError</code> - Raised if the value cannot be converted to provided type</li> <li><code>KeyboardInterrupt</code> - Raised when keyboard interrupt is encountered and Config.raise_on_interrupt is True</li> </ul> <p>Returns:</p> <p>Union[T, str]: Returns a value formatted as provided type or string if no type is provided</p> <p></p> <p></p>"},{"location":"api/#select","title":"select","text":"<pre><code>def select(options: List[Union[str, T]],\n           preprocessor: Callable[[T], str] = lambda val: str(val),\n           cursor: str = '&gt;',\n           cursor_style: str = 'pink1',\n           cursor_index: int = 0,\n           return_index: bool = False,\n           strict: bool = False,\n           pagination: bool = False,\n           page_size: int = 5) -&gt; Union[int, Any, None]\n</code></pre> <p>[view_source]</p> <p>A prompt that allows selecting one option from a list of options</p> <p>Arguments:</p> <ul> <li><code>options</code> List[Union[str, T]] - A list of options to select from. If <code>preprocessor</code> is left as default (not passed),   it needs to be a list of strings or objects with a <code>__str__</code> method. Otherwise,   you can pass a <code>preprocessor</code> to create a string representation of arbitrary data-structures.</li> <li><code>preprocessor</code> Callable[[T], str] - A callable that can be used to preprocess the list of options prior to printing.   For example, if you passed a <code>Person</code> object with <code>name</code> attribute, preprocessor   could be <code>lambda person: person.name</code> to just show the content of <code>name</code> attribute   in the select dialog. Defaults to <code>lambda val: val</code></li> <li><code>cursor</code> str, optional - Cursor that is going to appear in front of currently selected option. Defaults to '&gt; '.</li> <li><code>cursor_style</code> str, optional - Rich friendly style for the cursor. Defaults to 'pink1'.</li> <li><code>cursor_index</code> int, optional - Option can be preselected based on its list index. Defaults to 0.</li> <li><code>return_index</code> bool, optional - If <code>True</code>, <code>select</code> will return the index of selected element in options. Defaults to <code>False</code>.</li> <li><code>strict</code> bool, optional - If empty <code>options</code> is provided and strict is <code>False</code>, None will be returned,   if it's <code>True</code>, <code>ValueError</code> will be thrown. Defaults to False.</li> <li><code>pagination</code> bool, optional - If <code>True</code>, pagination will be used. Defaults to False.</li> <li><code>page_size</code> int, optional - Number of options to show on a single page if pagination is enabled. Defaults to 5.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - Thrown if no <code>options</code> are provided and strict is <code>True</code></li> <li><code>KeyboardInterrupt</code> - Raised when keyboard interrupt is encountered and Config.raise_on_interrupt is True</li> </ul> <p>Returns:</p> <p>Union[int, str, None]: Selected value or the index of a selected option or <code>None</code></p> <p></p> <p></p>"},{"location":"api/#select_multiple","title":"select_multiple","text":"<pre><code>def select_multiple(options: List[Union[str, T]],\n                    preprocessor: Callable[[T], str] = lambda val: str(val),\n                    tick_character: str = '\u2713',\n                    tick_style: str = 'pink1',\n                    cursor_style: str = 'pink1',\n                    ticked_indices: Optional[List[int]] = None,\n                    cursor_index: int = 0,\n                    minimal_count: int = 0,\n                    maximal_count: Optional[int] = None,\n                    return_indices: bool = False,\n                    strict: bool = False,\n                    pagination: bool = False,\n                    page_size: int = 5) -&gt; List[Union[int, Any]]\n</code></pre> <p>[view_source]</p> <p>A prompt that allows selecting multiple options from a list of options</p> <p>Arguments:</p> <ul> <li><code>options</code> List[Union[str, T]] - A list of options to select from. If <code>preprocessor</code> is left as default (not passed),   it needs to be a list of strings or objects with a <code>__str__</code> method. Otherwise,   you can pass a <code>preprocessor</code> to create a string representation of arbitrary data-structures.</li> <li><code>preprocessor</code> Callable[[T], str] - A callable that can be used to preprocess the list of options prior to printing.   For example, if you passed a <code>Person</code> object with <code>name</code> attribute, preprocessor   could be <code>lambda person: person.name</code> to just show the content of <code>name</code> attribute   in the select_multiple dialog. Defaults to <code>lambda val: val</code></li> <li><code>tick_character</code> str, optional - Character that will be used as a tick in a checkbox. Defaults to 'x'.</li> <li><code>tick_style</code> str, optional - Rich friendly style for the tick character. Defaults to 'pink1'.</li> <li><code>cursor_style</code> str, optional - Rich friendly style for the option when the cursor is currently on it. Defaults to 'pink1'.</li> <li><code>ticked_indices</code> Optional[List[int]], optional - Indices of options that are pre-ticked when the prompt appears. Defaults to None.</li> <li><code>cursor_index</code> int, optional - Index of the option cursor starts at. Defaults to 0.</li> <li><code>minimal_count</code> int, optional - Minimal count of options that need to be selected. Defaults to 0.</li> <li><code>maximal_count</code> Optional[int], optional - Maximal count of options that need to be selected. Defaults to None.</li> <li><code>return_indices</code> bool, optional - If <code>True</code>, <code>select_multiple</code> will return the indices   of ticked elements in options. Defaults to <code>False</code>.</li> <li><code>strict</code> bool, optional - If empty <code>options</code> is provided and strict is <code>False</code>, None will be returned,   if it's <code>True</code>, <code>ValueError</code> will be thrown. Defaults to False.</li> <li><code>pagination</code> bool, optional - If <code>True</code>, pagination will be used. Defaults to False.</li> <li><code>page_size</code> int, optional - Number of options to show on a single page if pagination is enabled. Defaults to 5.</li> </ul> <p>Raises:</p> <ul> <li><code>KeyboardInterrupt</code> - Raised when keyboard interrupt is encountered and Config.raise_on_interrupt is True</li> </ul> <p>Returns:</p> <p>Union[List[str], List[int]]: A list of selected values or indices of selected options</p> <p></p> <p></p>"},{"location":"api/#confirm","title":"confirm","text":"<pre><code>def confirm(question: str,\n            yes_text: str = 'Yes',\n            no_text: str = 'No',\n            has_to_match_case: bool = False,\n            enter_empty_confirms: bool = True,\n            default_is_yes: bool = False,\n            cursor: str = '&gt;',\n            cursor_style: str = 'pink1',\n            char_prompt: bool = True) -&gt; Optional[bool]\n</code></pre> <p>[view_source]</p> <p>A prompt that asks a question and offers two responses</p> <p>Arguments:</p> <ul> <li><code>question</code> str - Question to be asked</li> <li><code>yes_text</code> str, optional - Text of the positive response. Defaults to 'Yes'.</li> <li><code>no_text</code> str, optional - Text of the negative response. Defaults to 'No'.</li> <li><code>has_to_match_case</code> bool, optional - Check if typed response matches case. Defaults to False.</li> <li><code>enter_empty_confirms</code> bool, optional - No response is confirmation. Defaults to True.</li> <li><code>default_is_yes</code> bool, optional - Default is Yes. Defaults to False.</li> <li><code>cursor</code> str, optional - What character(s) to use as a cursor. Defaults to '&gt; '.</li> <li><code>cursor_style</code> str, optional - Rich friendly style for the cursor. Defaults to 'pink1'.</li> <li><code>char_prompt</code> bool, optional - Print [Y/n] after the question. Defaults to True.</li> </ul> <p>Raises:</p> <ul> <li><code>KeyboardInterrupt</code> - Raised when keyboard interrupt is encountered and Config.raise_on_interrupt is True</li> </ul> <p>Returns:</p> <p>Optional[bool]</p> <p></p> <p></p>"},{"location":"api/#class-spinner","title":"Class Spinner","text":"<pre><code>class Spinner()\n</code></pre> <p>[view_source]</p> <p></p> <p></p>"},{"location":"api/#__init__","title":"__init__","text":"<pre><code>def __init__(spinner_characters: List[str] = DOTS,\n             text: str = 'Loading...',\n             refresh_per_second: float = 10,\n             transient: bool = True)\n</code></pre> <p>[view_source]</p> <p>Creates a spinner which can be used to provide some user feedback during long processing</p> <p>Arguments:</p> <ul> <li><code>spinner_characters</code> List[str] - List of strings that will be displayed in sequence by a spinner</li> <li><code>text</code> str - Static text that will be shown after the spinner. Defaults to <code>Loading...</code></li> <li><code>refresh_per_second</code> float, optional - Number of refreshes the spinner will do a second, this will affect   the fluidity of the \"animation\". Defaults to 10.</li> <li><code>transient</code> bool, optional - If the spinner will disappear after it's done, otherwise not. Defaults to True.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - Raised when no <code>spinner_characters</code> are provided in</li> </ul> <p></p> <p></p>"},{"location":"api/#start","title":"start","text":"<pre><code>def start() -&gt; None\n</code></pre> <p>[view_source]</p> <p>Starts the spinner</p> <p></p> <p></p>"},{"location":"api/#stop","title":"stop","text":"<pre><code>def stop() -&gt; None\n</code></pre> <p>[view_source]</p> <p>Stops the spinner</p>"},{"location":"examples/","title":"More Examples","text":""},{"location":"examples/#selectselect_multiple","title":"<code>select</code>/<code>select_multiple</code>","text":""},{"location":"examples/#functionality","title":"Functionality","text":""},{"location":"examples/#return-index","title":"Return index","text":"<p>Selective elements default to return the selected item (in case of <code>select</code>) or list of items (in case of <code>select_multiple</code>). This behavior can be modified by <code>return_index</code> parameter (or <code>return_indices</code> in case of the latter), see example,</p> <pre><code>result_index = select(options=['I\\'ll be returned as 0', 'I\\'ll be returned as 1'],\n                      return_index=True)\n</code></pre>"},{"location":"examples/#starting-cursor-index","title":"Starting cursor index","text":"<p>By default cursor is placed on the first element, this can be configured by <code>cursor_index</code> parameter as follows,</p> <pre><code>results = select(['Not here either', 'Not here', 'Start from here'],\n                 cursor_index=1)\n</code></pre>"},{"location":"examples/#preticked-indices-for-select_multiple","title":"Preticked indices for <code>select_multiple</code>","text":"<p>You can have preticked options using <code>ticked_indices</code> in <code>select_multiple</code>:</p> <pre><code>loved_children = select_multiple(['Oldest child', 'Middle child', 'Youngest Child'],\n                                 ticked_indices=[0,2])\n</code></pre>"},{"location":"examples/#maximal-and-minimal-count-for-select_multiple","title":"Maximal and minimal count for <code>select_multiple</code>","text":"<p>With <code>select_multiple</code> you can restrict maximum and minimum count of elements using <code>maximal_count</code> and <code>minimal_count</code> respectively,</p> <pre><code>pizza_toppings = select_multiple(['pineapple', 'olives', 'anchovies', 'mozzarella', 'parma ham']\n                                 maximal_count=3,\n                                 minimal_count=1)\n</code></pre>"},{"location":"examples/#styling","title":"Styling","text":"<p>Tip</p> <p>For styling you can leverage numerous styling options provided by rich</p>"},{"location":"examples/#style-as-text","title":"Style as text","text":"<pre><code>stylish = select(options = [\"red\", \"on\", \"white\"],\n                 cursor = \"x\",\n                 cursor_style= \"red on white\")\n</code></pre>"},{"location":"examples/#style-as-hex","title":"Style as hex","text":"<pre><code>selections = select_multiple(options = [\"s\", \"h\", \"e\", \"\", \"b\", \"e\", \"l\", \"i\", \"e\", \"v\", \"e\", \"d\"],\n                             tick_style=\"#af00ff\",\n                             ticked_indices=[1,2,6,7,8,11])\n</code></pre>"},{"location":"examples/#cursor-characters","title":"Cursor characters","text":""},{"location":"examples/#emoji-as-a-cursor","title":"Emoji as a cursor","text":"<p>Bug</p> <p>Some emojis can appear as one character instead of two!</p> <pre><code>result = select(options = [\"here\", \"comes\", \"the\", \"sun\"],\n                cursor = \"\ud83c\udf1e\")\n</code></pre>"},{"location":"examples/#non-ascii-as-a-cursor","title":"Non-ascii as a cursor","text":"<pre><code>result = select(options = [\"hardcore\", \"unicode\"],\n                cursor = \"\u21c9\")\n</code></pre>"},{"location":"examples/#multi-character-cursorsticks","title":"Multi-character cursors/ticks","text":"<p>Tip</p> <p>You can use multiple characters as a cursor</p> <pre><code>correct_abba_lyric = select_multiple(options = [\"queen\", \"bean\"],\n                                     tick_character = \"dancing\")\n</code></pre>"},{"location":"examples/#prompt","title":"<code>prompt</code>","text":""},{"location":"examples/#functionality_1","title":"Functionality","text":"<p>You can have a default prompt, which will collect the user typed response to the mood variable as string</p> <pre><code>mood = prompt(\"How are you today?\")\n</code></pre>"},{"location":"examples/#validation","title":"Validation","text":"<p>Additionally, you can validate the input using some sort of Callable <code>validator</code>, for example a lambda expression to make sure input is not numeric,</p> <pre><code>answer = prompt(prompt=\"What is the answer to life the universe and everything?\"\n                validator=lambda val: not val.isnumeric())\n</code></pre>"},{"location":"examples/#type-conversion","title":"Type Conversion","text":"<p>You might want to convert types for some sort of downstream functionality using <code>target_type</code>,</p> <p>Note</p> <p>Validation is always second to type conversion</p> <pre><code>number_between_1_and_10 = prompt(\"Give me a number between 1 and 10\",\n                                 target_type=int\n                                 validator=lambda n: 0 &lt; n &lt;= 10)\n</code></pre>"},{"location":"examples/#hiddensecure-input","title":"Hidden/secure input","text":"<p>For sensitive input, <code>secure</code> flag can be utilized, replacing user entered input with <code>*</code></p> <pre><code>very_secret_info = prompt(\"Type you API key, hehe\",\n                          secure=True)\n</code></pre>"},{"location":"examples/#completion","title":"Completion","text":"<p>You can provide a python callable such as <code>Callable[[str], List[str]]</code> to provide completion options. String passed to the callable is the current user input.</p> <pre><code>favorite_color = prompt(\"What is your favorite color?\",\n                        completion=lambda _: [\"pink\", \"PINK\", \"P1NK\"])\n</code></pre> <p>A more complex example with path completion:</p> <pre><code>from os import listdir\nfrom pathlib import Path\n\n# ugly hacky path completion callable:\ndef path_completion(str_path: str = \"\"):\n    if not str_path:\n        return []\n    try:\n        path = Path(str_path)\n        rest = ''\n        if not path.exists():\n            str_path, rest = str_path.rsplit('/', 1)\n            path = Path(str_path or '/')\n\n        filtered_list_dir = [i for i in listdir(path) if i.startswith(rest)]\n\n        if not path.is_absolute():\n            return ['./'+str(Path(path)/i) for i in filtered_list_dir]\n        else:\n            return [str(Path(path)/i) for i in filtered_list_dir]\n    except Exception as e:\n        return []\n\nprompt(\"&gt;\", completion=path_completion)\n</code></pre>"},{"location":"examples/#spinners","title":"Spinners","text":""},{"location":"examples/#styling_1","title":"Styling","text":""},{"location":"examples/#spinner-animation","title":"Spinner Animation","text":"<p>There are few built in spinner animations, namely: ARC, ARROWS, BARS, CLOCK, DIAMOND, DOT, DOTS, LINE, LOADING and MOON</p> <p>Each of these can be used in a spinner:</p> <pre><code>from beaupy.spinners import Spinner, ARC\nspinner = Spinner(ARC, \"Doing some heavy work\")\nspinner.start()\n</code></pre> <p>All that \"animations\" are, is but a list of string, so making your own is as trivial as this:</p> <pre><code>from beaupy.spinners import Spinner\nspinner = Spinner(['whee', 'whe ', 'wh  ', 'w   ', 'wh  ', 'whe ', 'whee'], \"Whee!\")\nspinner.start()\n</code></pre>"},{"location":"examples/#rich-styling","title":"Rich styling","text":"<p>Every text in spinner does accept and respect rich styles, so the following works:</p> <pre><code>from beaupy.spinners import Spinner\nspinner = Spinner(['[red]\u2b24[/red] ', '[green]\u2b24[/green] ', '[blue]\u2b24[/blue] '], '[pink1]Setting[/pink1] colors!')\nspinner.start()\n</code></pre>"},{"location":"examples/#animation-speed","title":"Animation speed","text":"<p>Animation speed can be set using <code>refresh_per_second</code> parameter:</p> <pre><code>from beaupy.spinners import Spinner, LOADING\nspinner = Spinner(LOADING, \"something\", refresh_per_second=4)\nspinner.start()\n</code></pre>"},{"location":"examples/#global-configuration","title":"Global Configuration","text":"<p><code>beaupy</code> exposes global configuration to configure behaviour of the CLI elements globally. There are currently 3 options:</p> <ul> <li><code>raise_on_interrupt</code>: If <code>True</code>, functions will raise <code>KeyboardInterrupt</code> whenever one is encountered when waiting for input,         otherwise, they will return some sane alternative to their usual return. For <code>select</code>, <code>prompt</code> and <code>confirm</code> this means <code>None</code>,         while for <code>select_multiple</code> it means an empty list - <code>[]</code>. Defaults to <code>False</code>.</li> <li><code>raise_on_escape</code>: If <code>True</code>, functions will raise <code>Abort</code> whenever the escape key is encountered when waiting for input, otherwise,         they will return some sane alternative to their usual return. For <code>select</code>, <code>prompt</code> and <code>confirm</code> this means <code>None</code>, while for         <code>select_multiple</code> it means an empty list - <code>[]</code>.  Defaults to <code>False</code>.</li> <li><code>transient</code>: If <code>False</code>, elements will remain displayed after their context has ended. Defaults to <code>True</code>.</li> </ul> <p>You can set these options like follows:</p> <pre><code>from beaupy import Config\n\nConfig.raise_on_interrupt = True\nConfig.raise_on_escape = True\nConfig.transient = False\n</code></pre>"},{"location":"examples/#usage","title":"Usage","text":"<p>For example, if you want to raise an exception when user presses <code>Ctrl+C</code> or <code>Esc</code> key, you can set <code>raise_on_interrupt</code> and <code>raise_on_escape</code> to <code>True</code>:</p> <pre><code>from beaupy import Config, select\n\nConfig.raise_on_interrupt = True\n\ntry:\n    result = select(['Option 1', 'Option 2'])\nexcept KeyboardInterrupt:\n    print(\"User pressed Ctrl+C\")\n\nprint(\"Result:\", result)\n</code></pre>"}]}